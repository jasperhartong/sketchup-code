---
description: Always use the SketchUp bridge to run/iterate on SketchUp code (never ask user to paste in Ruby Console)
alwaysApply: true
---

# SketchUp Bridge – Agent-Driven Iteration

**When running or iterating on SketchUp Ruby code, always use the bridge.** Do not ask the user to paste code into the SketchUp Ruby Console.

When you need to **run code inside SketchUp** and see results (e.g. test `Timmerman::SkeletonDimensions.run`, `.clear`, or any SketchUp Ruby):

1. **Ensure the listener is running in SketchUp**  
   **Option A (plugin — preferred):** Install `dist/timmerman_sketchup_bridge-1.0.0.rbz`, set the bridge directory to this project's `sketchup_bridge/` folder via *Extensions → SketchUp Bridge → Set Bridge Directory…*, then click *Start Listener*. The listener persists across sessions.  
   **Option B (manual):** Paste once in the Ruby Console:  
   `load '/Users/jasper/Timmerman/sketchup-code/sketchup_bridge/listener.rb'`

2. **Write the code to run**  
   Edit `sketchup_bridge/command.rb`. The default loads `core.rb` directly and calls run/clear:
   ```ruby
   core = File.expand_path('../plugins/timmerman_skeleton_dimensions/core.rb', __dir__)
   load core
   Timmerman::SkeletonDimensions.debug_mode = true
   Timmerman::SkeletonDimensions.clear
   Timmerman::SkeletonDimensions.run
   "OK"
   ```
   The algorithm lives in `plugins/timmerman_skeleton_dimensions/core.rb` — edit that file, then re-run the bridge to test it.

3. **Run and wait for result**  
   Execute: `ruby sketchup_bridge/run_and_wait.rb`  
   The script touches `command.rb` so the listener runs it, then waits for `result.txt` written *this* run. It only succeeds when SketchUp actually runs the command (so you never get stale output). If the listener is not running, it times out and fails.

4. **Use the output**  
   stdout/stderr from the command are in the printed result. Parse it to decide the next edit and repeat.

5. **If the bridge is not connected**  
   When the listener is not running in SketchUp (or the IDE was not opened with the correct port), `run_and_wait.rb` will **fail** after a short timeout and print a clear **"BRIDGE NOT CONNECTED"** message. **Report that to the user**: tell them the bridge could not reach SketchUp and they need to start the listener in SketchUp (Extensions → SketchUp Bridge → Start Listener, or load the listener from the Ruby Console) and set the bridge directory, then rerun.

Do not ask the user to paste code into the Ruby Console for iteration; use the bridge (edit `command.rb` → run `run_and_wait.rb` → read output).

---

## Iteration Methodology

Follow this pattern for every non-trivial change:

### 1. Discover with a one-off diagnostic script
Before touching production code, write a temporary `command.rb` that inspects the live SketchUp state:
- Print every child's name, classification, bounding-box projections, and why it would or would not receive a dimension.
- Print intermediate computed values (origin, extents, dedup keys, filter results).
- Use explicit `puts` with clear labels so the output is self-documenting.

This surfaces root causes (wrong transform, missed nesting, bad classification) before any code is changed.

### 2. Write generic code — no hardcoding
Fix the algorithm in `plugins/timmerman_skeleton_dimensions/core.rb`:
- The fix must work for **all** inputs, not just the specific beam that triggered the bug.
- Never reference specific component names, IDs, or positions in production logic.
- Add constants for thresholds (e.g. `MIN_BEAM_SPAN`) and document their intent with comments.

### 3. Validate with a targeted one-off script — ALWAYS, do not skip
After the fix, write another temporary `command.rb` that:
- Re-runs the production code (`Dimensions.clear` + `Dimensions.run`).
- Then **programmatically reads back the result from SketchUp** (e.g. query `model.entities.grep(Sketchup::DimensionLinear)` and print each dimension's `.text`, anchor points, and 3D distance) to confirm the values are correct.
- Compare computed expected values against what SketchUp actually stored; print PASS/FAIL with a reason.
- **Never declare success based on the run log alone** — always verify the actual rendered output through the bridge before telling the user it is fixed.
- Leave the final `command.rb` as the normal run command (`Timmerman::SkeletonDimensions.clear` + `.run`) once validation passes.

**`DimensionLinear` audit pattern** (verified working). When auditing dimensions added by the plugin, use the same scope as clear (sublayer + target_entities):
```ruby
model = Sketchup.active_model
inst = Timmerman::SkeletonDimensions.selected_component_instance(model.selection)
sublayer = Timmerman::SkeletonDimensions.find_or_create_maten_sublayer(model, inst)
target_entities = Timmerman::SkeletonDimensions.entities_containing_instance(inst)
dims = target_entities.grep(Sketchup::DimensionLinear).select { |d| d.layer == sublayer }
dims.each_with_index do |d, i|
  p1 = d.start[1]   # start returns [nil_or_entity, Point3d]
  p2 = d.send(:end)[1]
  puts "dim #{i}: text='#{d.text}' 3d_dist=#{(p1.distance(p2)*25.4).round(1)}mm"
end
```

### Pitfalls learned
- **`e.bounds` is already in parent space** — do not re-apply `e.transformation` when converting to world coords; store `accumulated_t` (not `accumulated_t * e.transformation`) for leaf entities.
- **Groups are transparent containers** — recurse into them; treat only `ComponentInstance` leaves as beams.
- **SketchUp internal units are inches** — `.round(2)` in debug output shows inches, not mm; convert with `* 25.4` for readability and use `.mm` constants for comparisons.
- **Only the right edge of vertical beams** — push only `hs.max` into `far_x`; adding `hs.min` (left edge) doubles the cumulative dims unnecessarily.
- **Cumulative dim anchors must be coplanar** — construct the second anchor as `origin_pt + h_diff * view_h` (not a raw bbox corner) so SketchUp measures a pure in-plane horizontal distance. Using real 3D corners from different beams introduces a depth component that inflates the shown value.
- **Verify dimension values via the bridge** — `d.start` returns `[entity_or_nil, Point3d]`; use index `[1]` for the Point3d. `d.end` is a Ruby keyword; call it as `d.send(:end)`.
- **Audit dimensions the same way clear finds them** — When validating dimensions in a one-off script, use the same scope as `clear`: `target_entities = entities_containing_instance(inst)`, `sublayer = find_or_create_maten_sublayer(model, inst)`, and `dims = target_entities.grep(Sketchup::DimensionLinear).select { |d| d.layer == sublayer }`. Otherwise you may include dimensions from other layers and get wrong counts or wrong dimensions.
