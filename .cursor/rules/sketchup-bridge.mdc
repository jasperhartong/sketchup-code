---
description: Always use the SketchUp bridge to run/iterate on SketchUp code (never ask user to paste in Ruby Console)
alwaysApply: true
---

# SketchUp Bridge – Agent-Driven Iteration

**When running or iterating on SketchUp Ruby code, always use the bridge.** Do not ask the user to paste code into the SketchUp Ruby Console.

When you need to **run code inside SketchUp** and see results (e.g. test `Dimensions.run`, `Dimensions.clear`, or any SketchUp Ruby):

1. **Ensure the listener is running in SketchUp**  
   User must have run once in SketchUp Ruby Console:  
   `load '/Users/jasper/Timmerman/sketchup-code/sketchup_bridge/listener.rb'`

2. **Write the code to run**  
   Edit `sketchup_bridge/command.rb`. Put the exact Ruby you want SketchUp to execute. Example for current selection:
   ```ruby
   project_root = File.expand_path(File.join(File.dirname(__FILE__), '..'))
   load File.join(project_root, 'Dimensions.rb')
   Dimensions.clear
   Dimensions.run
   "OK"
   ```
   For a named instance (e.g. `test001`), use the existing helper in the default `command.rb` (select_instance_by_name).

3. **Run and wait for result**  
   Execute: `ruby sketchup_bridge/run_and_wait.rb`  
   This waits until SketchUp has run `command.rb` (listener polls every 2s), then prints `result.txt`.

4. **Use the output**  
   stdout/stderr from the command are in the printed result. Parse it to decide the next edit and repeat.

Do not ask the user to paste code into the Ruby Console for iteration; use the bridge (edit `command.rb` → run `run_and_wait.rb` → read output).

---

## Iteration Methodology

Follow this pattern for every non-trivial change:

### 1. Discover with a one-off diagnostic script
Before touching production code, write a temporary `command.rb` that inspects the live SketchUp state:
- Print every child's name, classification, bounding-box projections, and why it would or would not receive a dimension.
- Print intermediate computed values (origin, extents, dedup keys, filter results).
- Use explicit `puts` with clear labels so the output is self-documenting.

This surfaces root causes (wrong transform, missed nesting, bad classification) before any code is changed.

### 2. Write generic code — no hardcoding
Fix the algorithm in the production `.rb` file (e.g. `Dimensions.rb`):
- The fix must work for **all** inputs, not just the specific beam that triggered the bug.
- Never reference specific component names, IDs, or positions in production logic.
- Add constants for thresholds (e.g. `MIN_BEAM_SPAN`) and document their intent with comments.

### 3. Validate with a targeted one-off script — ALWAYS, do not skip
After the fix, write another temporary `command.rb` that:
- Re-runs the production code (`Dimensions.clear` + `Dimensions.run`).
- Then **programmatically reads back the result from SketchUp** (e.g. query `model.entities.grep(Sketchup::DimensionLinear)` and print each dimension's `.text`, anchor points, and 3D distance) to confirm the values are correct.
- Compare computed expected values against what SketchUp actually stored; print PASS/FAIL with a reason.
- **Never declare success based on the run log alone** — always verify the actual rendered output through the bridge before telling the user it is fixed.
- Leave the final `command.rb` as the normal run command (`Dimensions.clear` + `Dimensions.run`) once validation passes.

**`DimensionLinear` audit pattern** (verified working):
```ruby
model.entities.grep(Sketchup::DimensionLinear).each_with_index do |d, i|
  p1 = d.start[1]   # start returns [nil_or_entity, Point3d]
  p2 = d.send(:end)[1]
  puts "dim #{i}: text='#{d.text}'  3d_dist=#{(p1.distance(p2)*25.4).round(1)}mm"
end
```

### Pitfalls learned
- **`e.bounds` is already in parent space** — do not re-apply `e.transformation` when converting to world coords; store `accumulated_t` (not `accumulated_t * e.transformation`) for leaf entities.
- **Groups are transparent containers** — recurse into them; treat only `ComponentInstance` leaves as beams.
- **SketchUp internal units are inches** — `.round(2)` in debug output shows inches, not mm; convert with `* 25.4` for readability and use `.mm` constants for comparisons.
- **Only the right edge of vertical beams** — push only `hs.max` into `far_x`; adding `hs.min` (left edge) doubles the cumulative dims unnecessarily.
- **Cumulative dim anchors must be coplanar** — construct the second anchor as `origin_pt + h_diff * view_h` (not a raw bbox corner) so SketchUp measures a pure in-plane horizontal distance. Using real 3D corners from different beams introduces a depth component that inflates the shown value.
- **Verify dimension values via the bridge** — `d.start` returns `[entity_or_nil, Point3d]`; use index `[1]` for the Point3d. `d.end` is a Ruby keyword; call it as `d.send(:end)`.
